#include "FreeRTOS.h"
#include "task.h"
#include "cmsis_os.h"
#include "stm32f2xx_hal.h"
#include "adc.h"
#include "math_func.h"
#include "float.h"

#define min(a, b) (((a) < (b)) ? (a) : (b))
#define max(a, b) (((a) > (b)) ? (a) : (b))

uint16_t Circ_buffer_median(uint16_t* buffer, uint16_t newValue)
{
    uint16_t i;
    uint16_t len;

    len = sizeof(buffer) / 2;
    for (i = len - 1; i > 0; i--) {
        buffer[i] = buffer[i - 1];
    }
    buffer[0] = newValue;
    return Mediana_filter16(buffer, len);
}

unsigned short Mediana_filter16(unsigned short* M_Pointer, unsigned char qty)
{
    unsigned short mediana_masive[17];
    unsigned char i;
    unsigned short temp, max = 0;
    unsigned char pmax, high;

    for (i = 0; i < qty; i++) { // ???????????? ????, ????? ?? ??????? ????????
        mediana_masive[i] = *M_Pointer++;
    }

    high = (qty - 1); //????????, ??? ????????? ??????? ????? ???????

    //???? ???? ??????? ???????? ?????? ??? ????? ???? - ?????? ?? ??????? ?
    //???????? ????????? ?? ?????
    //????? ???????? ?? ??????? ????, ? ??? ???? ?? ?????? ?? ????.

    while (high != 0) { //(?.?. ???? ?? ?????? ?????????, ? ????????? 0 ????? 255 (0xFF)

        //??????????
        temp = 1; //??????? ??? ?????????? ???? ????

        while (temp != 0) {
            pmax = high; // ???????, ??? ???? ???????????? ??? ?????????
            temp = 0; //???????, ??? ??? ???????????? ???, ?? ? ?????????? ???????
            //?????? ???
            for (i = 0; i < high; i++) {

                if (mediana_masive[i] > mediana_masive[pmax]) { //???? ??????

                    /*?????? ???????*/
                    max = mediana_masive[pmax];
                    mediana_masive[pmax] = mediana_masive[i];
                    mediana_masive[i] = max;
                    temp++;
                }
            }
        }

        //??? ?? ???, ?????? ??? ????????????
        high--; //????????? ???? ?????? ? ??????????? ??? ? ??????? ???????????
    }

    return mediana_masive[qty / 2];
}

/*===================================================================================================*/
/*===================================== MedianFilter ================================================*/
/*===================================================================================================*/
void BottomUpMerge(float A[], unsigned char iLeft, unsigned char iRight, unsigned char iEnd, float B[])
{
    unsigned char i0 = iLeft;
    unsigned char i1 = iRight;
    unsigned char j;

    /* While there are elements in the left or right lists */
    for (j = iLeft; j < iEnd; j++) {
        /* If left list head exists and is <= existing right list head */
        if (i0 < iRight && (i1 >= iEnd || A[i0] <= A[i1])) {
            B[j] = A[i0];
            i0 = i0 + 1;
        }
        else {
            B[j] = A[i1];
            i1 = i1 + 1;
        }
    }
}

float MedianFilter(float A[], unsigned char n)
{
    float answer = 0;
    float B[16];
    float* pointerA = A;
    float* pointerB = B;
    unsigned char width;
    unsigned char i;

    /* Each 1-element run in A is already "sorted". */

    /* Make successively longer sorted runs of length 2, 4, 8, 16... until whole array is sorted. */
    for (width = 1; width < n; width = 2 * width) {
        /* Array A is full of runs of length width. */
        for (i = 0; i < n; i = i + 2 * width) {
            /* Merge two runs: A[i:i+width-1] and A[i+width:i+2*width-1] to B[] */
            /* or copy A[i:n-1] to B[] ( if(i+width >= n) ) */
            BottomUpMerge(pointerA, i, min(i + width, n), min(i + 2 * width, n), pointerB);
        }
        /* Now work array B is full of runs of length 2*width. */
        /* Copy array B to array A for next iteration. */
        // CopyArray(A, B, n);
        /* A more efficient implementation would swap the roles of A and B */
        if (pointerA == A) {
            pointerA = B;
            pointerB = A;
        }
        else {
            pointerA = A;
            pointerB = B;
        }
        /* Now array A is full of runs of length 2*width. */
    }
    answer = B[n / 2];
    return answer;
}

float slow_median(int n, float* list)
/* find median by slow sorting, changes list */
{
    int k, k2;
    float item1, item2;

    for (k = 0; k < n; k++) {
        item1 = list[k];

        /* assume everything up to k is sorted */
        for (k2 = k; k2 > 0; k2--) {
            item2 = list[k2 - 1];
            if (item1 >= item2)
                break;
            list[k2] = item2;
        }
        list[k2] = item1;
    }

    return list[n / 2];
}
